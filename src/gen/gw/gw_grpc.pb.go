// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: dsl/gw.proto

package gw

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Acl_Login_FullMethodName     = "/gw.Acl/login"
	Acl_LoginBack_FullMethodName = "/gw.Acl/loginBack"
	Acl_DiscBack_FullMethodName  = "/gw.Acl/discBack"
	Acl_Team_FullMethodName      = "/gw.Acl/team"
	Acl_Addr_FullMethodName      = "/gw.Acl/addr"
	Acl_GwReg_FullMethodName     = "/gw.Acl/gwReg"
	Acl_Traffic_FullMethodName   = "/gw.Acl/traffic"
)

// AclClient is the client API for Acl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AclClient interface {
	// 登录
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginRep, error)
	// 登录回调
	LoginBack(ctx context.Context, in *LoginBack, opts ...grpc.CallOption) (*Id32Rep, error)
	// 断线回调
	DiscBack(ctx context.Context, in *LoginBack, opts ...grpc.CallOption) (*Id32Rep, error)
	// 组查询 tid
	Team(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*TeamRep, error)
	// 代理查询
	Addr(ctx context.Context, in *AddrReq, opts ...grpc.CallOption) (*AddrRep, error)
	// 分布式网关注册
	GwReg(ctx context.Context, in *GwRegReq, opts ...grpc.CallOption) (*BoolRep, error)
	// 流量上报
	Traffic(ctx context.Context, in *TrafficReq, opts ...grpc.CallOption) (*BoolRep, error)
}

type aclClient struct {
	cc grpc.ClientConnInterface
}

func NewAclClient(cc grpc.ClientConnInterface) AclClient {
	return &aclClient{cc}
}

func (c *aclClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginRep, error) {
	out := new(LoginRep)
	err := c.cc.Invoke(ctx, Acl_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) LoginBack(ctx context.Context, in *LoginBack, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Acl_LoginBack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) DiscBack(ctx context.Context, in *LoginBack, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Acl_DiscBack_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) Team(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*TeamRep, error) {
	out := new(TeamRep)
	err := c.cc.Invoke(ctx, Acl_Team_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) Addr(ctx context.Context, in *AddrReq, opts ...grpc.CallOption) (*AddrRep, error) {
	out := new(AddrRep)
	err := c.cc.Invoke(ctx, Acl_Addr_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) GwReg(ctx context.Context, in *GwRegReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Acl_GwReg_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclClient) Traffic(ctx context.Context, in *TrafficReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Acl_Traffic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AclServer is the server API for Acl service.
// All implementations should embed UnimplementedAclServer
// for forward compatibility
type AclServer interface {
	// 登录
	Login(context.Context, *LoginReq) (*LoginRep, error)
	// 登录回调
	LoginBack(context.Context, *LoginBack) (*Id32Rep, error)
	// 断线回调
	DiscBack(context.Context, *LoginBack) (*Id32Rep, error)
	// 组查询 tid
	Team(context.Context, *GidReq) (*TeamRep, error)
	// 代理查询
	Addr(context.Context, *AddrReq) (*AddrRep, error)
	// 分布式网关注册
	GwReg(context.Context, *GwRegReq) (*BoolRep, error)
	// 流量上报
	Traffic(context.Context, *TrafficReq) (*BoolRep, error)
}

// UnimplementedAclServer should be embedded to have forward compatible implementations.
type UnimplementedAclServer struct {
}

func (UnimplementedAclServer) Login(context.Context, *LoginReq) (*LoginRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAclServer) LoginBack(context.Context, *LoginBack) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginBack not implemented")
}
func (UnimplementedAclServer) DiscBack(context.Context, *LoginBack) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscBack not implemented")
}
func (UnimplementedAclServer) Team(context.Context, *GidReq) (*TeamRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Team not implemented")
}
func (UnimplementedAclServer) Addr(context.Context, *AddrReq) (*AddrRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Addr not implemented")
}
func (UnimplementedAclServer) GwReg(context.Context, *GwRegReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GwReg not implemented")
}
func (UnimplementedAclServer) Traffic(context.Context, *TrafficReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Traffic not implemented")
}

// UnsafeAclServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AclServer will
// result in compilation errors.
type UnsafeAclServer interface {
	mustEmbedUnimplementedAclServer()
}

func RegisterAclServer(s grpc.ServiceRegistrar, srv AclServer) {
	s.RegisterService(&Acl_ServiceDesc, srv)
}

func _Acl_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_LoginBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginBack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).LoginBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_LoginBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).LoginBack(ctx, req.(*LoginBack))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_DiscBack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginBack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).DiscBack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_DiscBack_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).DiscBack(ctx, req.(*LoginBack))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_Team_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).Team(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_Team_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).Team(ctx, req.(*GidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_Addr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).Addr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_Addr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).Addr(ctx, req.(*AddrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_GwReg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GwRegReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).GwReg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_GwReg_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).GwReg(ctx, req.(*GwRegReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Acl_Traffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclServer).Traffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Acl_Traffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclServer).Traffic(ctx, req.(*TrafficReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Acl_ServiceDesc is the grpc.ServiceDesc for Acl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Acl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gw.Acl",
	HandlerType: (*AclServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "login",
			Handler:    _Acl_Login_Handler,
		},
		{
			MethodName: "loginBack",
			Handler:    _Acl_LoginBack_Handler,
		},
		{
			MethodName: "discBack",
			Handler:    _Acl_DiscBack_Handler,
		},
		{
			MethodName: "team",
			Handler:    _Acl_Team_Handler,
		},
		{
			MethodName: "addr",
			Handler:    _Acl_Addr_Handler,
		},
		{
			MethodName: "gwReg",
			Handler:    _Acl_GwReg_Handler,
		},
		{
			MethodName: "traffic",
			Handler:    _Acl_Traffic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/gw.proto",
}

const (
	Pass_Req_FullMethodName   = "/gw.Pass/req"
	Pass_Send_FullMethodName  = "/gw.Pass/send"
	Pass_Prods_FullMethodName = "/gw.Pass/prods"
)

// PassClient is the client API for Pass service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PassClient interface {
	// 请求
	Req(ctx context.Context, in *PassReq, opts ...grpc.CallOption) (*DataRep, error)
	// 发送
	Send(ctx context.Context, in *PassReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 服务列表
	Prods(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ProdsRep, error)
}

type passClient struct {
	cc grpc.ClientConnInterface
}

func NewPassClient(cc grpc.ClientConnInterface) PassClient {
	return &passClient{cc}
}

func (c *passClient) Req(ctx context.Context, in *PassReq, opts ...grpc.CallOption) (*DataRep, error) {
	out := new(DataRep)
	err := c.cc.Invoke(ctx, Pass_Req_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passClient) Send(ctx context.Context, in *PassReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Pass_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passClient) Prods(ctx context.Context, in *Void, opts ...grpc.CallOption) (*ProdsRep, error) {
	out := new(ProdsRep)
	err := c.cc.Invoke(ctx, Pass_Prods_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PassServer is the server API for Pass service.
// All implementations should embed UnimplementedPassServer
// for forward compatibility
type PassServer interface {
	// 请求
	Req(context.Context, *PassReq) (*DataRep, error)
	// 发送
	Send(context.Context, *PassReq) (*Id32Rep, error)
	// 服务列表
	Prods(context.Context, *Void) (*ProdsRep, error)
}

// UnimplementedPassServer should be embedded to have forward compatible implementations.
type UnimplementedPassServer struct {
}

func (UnimplementedPassServer) Req(context.Context, *PassReq) (*DataRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Req not implemented")
}
func (UnimplementedPassServer) Send(context.Context, *PassReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedPassServer) Prods(context.Context, *Void) (*ProdsRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prods not implemented")
}

// UnsafePassServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PassServer will
// result in compilation errors.
type UnsafePassServer interface {
	mustEmbedUnimplementedPassServer()
}

func RegisterPassServer(s grpc.ServiceRegistrar, srv PassServer) {
	s.RegisterService(&Pass_ServiceDesc, srv)
}

func _Pass_Req_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassServer).Req(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pass_Req_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassServer).Req(ctx, req.(*PassReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pass_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pass_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassServer).Send(ctx, req.(*PassReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pass_Prods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassServer).Prods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Pass_Prods_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassServer).Prods(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

// Pass_ServiceDesc is the grpc.ServiceDesc for Pass service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Pass_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gw.Pass",
	HandlerType: (*PassServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "req",
			Handler:    _Pass_Req_Handler,
		},
		{
			MethodName: "send",
			Handler:    _Pass_Send_Handler,
		},
		{
			MethodName: "prods",
			Handler:    _Pass_Prods_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/gw.proto",
}

const (
	Gateway_Uid_FullMethodName        = "/gw.Gateway/uid"
	Gateway_Online_FullMethodName     = "/gw.Gateway/online"
	Gateway_Onlines_FullMethodName    = "/gw.Gateway/onlines"
	Gateway_Close_FullMethodName      = "/gw.Gateway/close"
	Gateway_Kick_FullMethodName       = "/gw.Gateway/kick"
	Gateway_Rid_FullMethodName        = "/gw.Gateway/rid"
	Gateway_Rids_FullMethodName       = "/gw.Gateway/rids"
	Gateway_Push_FullMethodName       = "/gw.Gateway/push"
	Gateway_Cids_FullMethodName       = "/gw.Gateway/cids"
	Gateway_GConn_FullMethodName      = "/gw.Gateway/gConn"
	Gateway_GDisc_FullMethodName      = "/gw.Gateway/gDisc"
	Gateway_GLast_FullMethodName      = "/gw.Gateway/gLast"
	Gateway_GPush_FullMethodName      = "/gw.Gateway/gPush"
	Gateway_GLasts_FullMethodName     = "/gw.Gateway/gLasts"
	Gateway_Send_FullMethodName       = "/gw.Gateway/send"
	Gateway_TPush_FullMethodName      = "/gw.Gateway/tPush"
	Gateway_TDirty_FullMethodName     = "/gw.Gateway/tDirty"
	Gateway_Revoke_FullMethodName     = "/gw.Gateway/revoke"
	Gateway_SetProxy_FullMethodName   = "/gw.Gateway/setProxy"
	Gateway_SetProds_FullMethodName   = "/gw.Gateway/setProds"
	Gateway_DialProxy_FullMethodName  = "/gw.Gateway/dialProxy"
	Gateway_DialsProxy_FullMethodName = "/gw.Gateway/dialsProxy"
	Gateway_UnreadTids_FullMethodName = "/gw.Gateway/unreadTids"
)

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	// uid查询
	Uid(ctx context.Context, in *CidReq, opts ...grpc.CallOption) (*UIdRep, error)
	// 在线查询
	Online(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*BoolRep, error)
	// 在线查询
	Onlines(ctx context.Context, in *GidsReq, opts ...grpc.CallOption) (*BoolsRep, error)
	// 关闭连接
	Close(ctx context.Context, in *CloseReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 软关闭连接
	Kick(ctx context.Context, in *KickReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 服务编号
	Rid(ctx context.Context, in *RidReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 服务编号
	Rids(ctx context.Context, in *RidsReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 简单推送
	Push(ctx context.Context, in *PushReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 查询cids
	Cids(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*CidsRep, error)
	// 注册监听gid
	GConn(ctx context.Context, in *GConnReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 断开监听gid
	GDisc(ctx context.Context, in *GDiscReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 组通知 gid
	GLast(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 组推送 // uri 主题 // binary 消息体 // qs 消息质量，0 内存发送成功 1 队列发送[unique 唯一标识(消息队列，一个标识只需要最新数据)] 2 last队列 3 last 队列持久化
	GPush(ctx context.Context, in *GPushReq, opts ...grpc.CallOption) (*Id64Rep, error)
	// 获取组更新消息
	GLasts(ctx context.Context, in *GLastsReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 点对点聊天
	Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// readfeed读扩散，常用于聊天室
	TPush(ctx context.Context, in *TPushReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 组更新、删除 tid
	TDirty(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*Id32Rep, error)
	// 撤销消息
	Revoke(ctx context.Context, in *RevokeReq, opts ...grpc.CallOption) (*BoolRep, error)
	// 设置代理
	SetProxy(ctx context.Context, in *ProxyReq, opts ...grpc.CallOption) (*BoolRep, error)
	// 设置服务列表
	SetProds(ctx context.Context, in *ProdsRep, opts ...grpc.CallOption) (*BoolRep, error)
	// 连接代理
	DialProxy(ctx context.Context, in *DialProxyReq, opts ...grpc.CallOption) (*BoolRep, error)
	// 连接代理复数
	DialsProxy(ctx context.Context, in *DialsProxyReq, opts ...grpc.CallOption) (*BoolsRep, error)
	// 未读消息.查询
	UnreadTids(ctx context.Context, in *UnreadTids, opts ...grpc.CallOption) (*Id32Rep, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) Uid(ctx context.Context, in *CidReq, opts ...grpc.CallOption) (*UIdRep, error) {
	out := new(UIdRep)
	err := c.cc.Invoke(ctx, Gateway_Uid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Online(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Gateway_Online_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Onlines(ctx context.Context, in *GidsReq, opts ...grpc.CallOption) (*BoolsRep, error) {
	out := new(BoolsRep)
	err := c.cc.Invoke(ctx, Gateway_Onlines_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Close(ctx context.Context, in *CloseReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Close_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Kick(ctx context.Context, in *KickReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Kick_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Rid(ctx context.Context, in *RidReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Rid_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Rids(ctx context.Context, in *RidsReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Rids_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Push(ctx context.Context, in *PushReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Push_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Cids(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*CidsRep, error) {
	out := new(CidsRep)
	err := c.cc.Invoke(ctx, Gateway_Cids_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GConn(ctx context.Context, in *GConnReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_GConn_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GDisc(ctx context.Context, in *GDiscReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_GDisc_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GLast(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_GLast_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GPush(ctx context.Context, in *GPushReq, opts ...grpc.CallOption) (*Id64Rep, error) {
	out := new(Id64Rep)
	err := c.cc.Invoke(ctx, Gateway_GPush_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) GLasts(ctx context.Context, in *GLastsReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_GLasts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Send(ctx context.Context, in *SendReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) TPush(ctx context.Context, in *TPushReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_TPush_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) TDirty(ctx context.Context, in *GidReq, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_TDirty_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Revoke(ctx context.Context, in *RevokeReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Gateway_Revoke_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) SetProxy(ctx context.Context, in *ProxyReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Gateway_SetProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) SetProds(ctx context.Context, in *ProdsRep, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Gateway_SetProds_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DialProxy(ctx context.Context, in *DialProxyReq, opts ...grpc.CallOption) (*BoolRep, error) {
	out := new(BoolRep)
	err := c.cc.Invoke(ctx, Gateway_DialProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DialsProxy(ctx context.Context, in *DialsProxyReq, opts ...grpc.CallOption) (*BoolsRep, error) {
	out := new(BoolsRep)
	err := c.cc.Invoke(ctx, Gateway_DialsProxy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) UnreadTids(ctx context.Context, in *UnreadTids, opts ...grpc.CallOption) (*Id32Rep, error) {
	out := new(Id32Rep)
	err := c.cc.Invoke(ctx, Gateway_UnreadTids_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations should embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	// uid查询
	Uid(context.Context, *CidReq) (*UIdRep, error)
	// 在线查询
	Online(context.Context, *GidReq) (*BoolRep, error)
	// 在线查询
	Onlines(context.Context, *GidsReq) (*BoolsRep, error)
	// 关闭连接
	Close(context.Context, *CloseReq) (*Id32Rep, error)
	// 软关闭连接
	Kick(context.Context, *KickReq) (*Id32Rep, error)
	// 服务编号
	Rid(context.Context, *RidReq) (*Id32Rep, error)
	// 服务编号
	Rids(context.Context, *RidsReq) (*Id32Rep, error)
	// 简单推送
	Push(context.Context, *PushReq) (*Id32Rep, error)
	// 查询cids
	Cids(context.Context, *GidReq) (*CidsRep, error)
	// 注册监听gid
	GConn(context.Context, *GConnReq) (*Id32Rep, error)
	// 断开监听gid
	GDisc(context.Context, *GDiscReq) (*Id32Rep, error)
	// 组通知 gid
	GLast(context.Context, *GidReq) (*Id32Rep, error)
	// 组推送 // uri 主题 // binary 消息体 // qs 消息质量，0 内存发送成功 1 队列发送[unique 唯一标识(消息队列，一个标识只需要最新数据)] 2 last队列 3 last 队列持久化
	GPush(context.Context, *GPushReq) (*Id64Rep, error)
	// 获取组更新消息
	GLasts(context.Context, *GLastsReq) (*Id32Rep, error)
	// 点对点聊天
	Send(context.Context, *SendReq) (*Id32Rep, error)
	// readfeed读扩散，常用于聊天室
	TPush(context.Context, *TPushReq) (*Id32Rep, error)
	// 组更新、删除 tid
	TDirty(context.Context, *GidReq) (*Id32Rep, error)
	// 撤销消息
	Revoke(context.Context, *RevokeReq) (*BoolRep, error)
	// 设置代理
	SetProxy(context.Context, *ProxyReq) (*BoolRep, error)
	// 设置服务列表
	SetProds(context.Context, *ProdsRep) (*BoolRep, error)
	// 连接代理
	DialProxy(context.Context, *DialProxyReq) (*BoolRep, error)
	// 连接代理复数
	DialsProxy(context.Context, *DialsProxyReq) (*BoolsRep, error)
	// 未读消息.查询
	UnreadTids(context.Context, *UnreadTids) (*Id32Rep, error)
}

// UnimplementedGatewayServer should be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) Uid(context.Context, *CidReq) (*UIdRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uid not implemented")
}
func (UnimplementedGatewayServer) Online(context.Context, *GidReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Online not implemented")
}
func (UnimplementedGatewayServer) Onlines(context.Context, *GidsReq) (*BoolsRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Onlines not implemented")
}
func (UnimplementedGatewayServer) Close(context.Context, *CloseReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedGatewayServer) Kick(context.Context, *KickReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Kick not implemented")
}
func (UnimplementedGatewayServer) Rid(context.Context, *RidReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rid not implemented")
}
func (UnimplementedGatewayServer) Rids(context.Context, *RidsReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rids not implemented")
}
func (UnimplementedGatewayServer) Push(context.Context, *PushReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedGatewayServer) Cids(context.Context, *GidReq) (*CidsRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cids not implemented")
}
func (UnimplementedGatewayServer) GConn(context.Context, *GConnReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GConn not implemented")
}
func (UnimplementedGatewayServer) GDisc(context.Context, *GDiscReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GDisc not implemented")
}
func (UnimplementedGatewayServer) GLast(context.Context, *GidReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GLast not implemented")
}
func (UnimplementedGatewayServer) GPush(context.Context, *GPushReq) (*Id64Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPush not implemented")
}
func (UnimplementedGatewayServer) GLasts(context.Context, *GLastsReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GLasts not implemented")
}
func (UnimplementedGatewayServer) Send(context.Context, *SendReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedGatewayServer) TPush(context.Context, *TPushReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TPush not implemented")
}
func (UnimplementedGatewayServer) TDirty(context.Context, *GidReq) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TDirty not implemented")
}
func (UnimplementedGatewayServer) Revoke(context.Context, *RevokeReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (UnimplementedGatewayServer) SetProxy(context.Context, *ProxyReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProxy not implemented")
}
func (UnimplementedGatewayServer) SetProds(context.Context, *ProdsRep) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProds not implemented")
}
func (UnimplementedGatewayServer) DialProxy(context.Context, *DialProxyReq) (*BoolRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DialProxy not implemented")
}
func (UnimplementedGatewayServer) DialsProxy(context.Context, *DialsProxyReq) (*BoolsRep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DialsProxy not implemented")
}
func (UnimplementedGatewayServer) UnreadTids(context.Context, *UnreadTids) (*Id32Rep, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnreadTids not implemented")
}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_Uid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Uid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Uid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Uid(ctx, req.(*CidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Online_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Online(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Online_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Online(ctx, req.(*GidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Onlines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Onlines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Onlines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Onlines(ctx, req.(*GidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Close_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Close(ctx, req.(*CloseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Kick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KickReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Kick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Kick_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Kick(ctx, req.(*KickReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Rid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Rid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Rid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Rid(ctx, req.(*RidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Rids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Rids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Rids_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Rids(ctx, req.(*RidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Push(ctx, req.(*PushReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Cids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Cids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Cids_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Cids(ctx, req.(*GidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GConn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GConnReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GConn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_GConn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GConn(ctx, req.(*GConnReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GDisc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GDiscReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GDisc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_GDisc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GDisc(ctx, req.(*GDiscReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GLast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GLast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_GLast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GLast(ctx, req.(*GidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GPush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPushReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GPush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_GPush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GPush(ctx, req.(*GPushReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_GLasts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GLastsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).GLasts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_GLasts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).GLasts(ctx, req.(*GLastsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Send(ctx, req.(*SendReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_TPush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TPushReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).TPush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_TPush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).TPush(ctx, req.(*TPushReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_TDirty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).TDirty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_TDirty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).TDirty(ctx, req.(*GidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Revoke_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Revoke(ctx, req.(*RevokeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_SetProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProxyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).SetProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_SetProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).SetProxy(ctx, req.(*ProxyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_SetProds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProdsRep)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).SetProds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_SetProds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).SetProds(ctx, req.(*ProdsRep))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DialProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialProxyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DialProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_DialProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DialProxy(ctx, req.(*DialProxyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DialsProxy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialsProxyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DialsProxy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_DialsProxy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DialsProxy(ctx, req.(*DialsProxyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_UnreadTids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreadTids)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).UnreadTids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_UnreadTids_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).UnreadTids(ctx, req.(*UnreadTids))
	}
	return interceptor(ctx, in, info, handler)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gw.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "uid",
			Handler:    _Gateway_Uid_Handler,
		},
		{
			MethodName: "online",
			Handler:    _Gateway_Online_Handler,
		},
		{
			MethodName: "onlines",
			Handler:    _Gateway_Onlines_Handler,
		},
		{
			MethodName: "close",
			Handler:    _Gateway_Close_Handler,
		},
		{
			MethodName: "kick",
			Handler:    _Gateway_Kick_Handler,
		},
		{
			MethodName: "rid",
			Handler:    _Gateway_Rid_Handler,
		},
		{
			MethodName: "rids",
			Handler:    _Gateway_Rids_Handler,
		},
		{
			MethodName: "push",
			Handler:    _Gateway_Push_Handler,
		},
		{
			MethodName: "cids",
			Handler:    _Gateway_Cids_Handler,
		},
		{
			MethodName: "gConn",
			Handler:    _Gateway_GConn_Handler,
		},
		{
			MethodName: "gDisc",
			Handler:    _Gateway_GDisc_Handler,
		},
		{
			MethodName: "gLast",
			Handler:    _Gateway_GLast_Handler,
		},
		{
			MethodName: "gPush",
			Handler:    _Gateway_GPush_Handler,
		},
		{
			MethodName: "gLasts",
			Handler:    _Gateway_GLasts_Handler,
		},
		{
			MethodName: "send",
			Handler:    _Gateway_Send_Handler,
		},
		{
			MethodName: "tPush",
			Handler:    _Gateway_TPush_Handler,
		},
		{
			MethodName: "tDirty",
			Handler:    _Gateway_TDirty_Handler,
		},
		{
			MethodName: "revoke",
			Handler:    _Gateway_Revoke_Handler,
		},
		{
			MethodName: "setProxy",
			Handler:    _Gateway_SetProxy_Handler,
		},
		{
			MethodName: "setProds",
			Handler:    _Gateway_SetProds_Handler,
		},
		{
			MethodName: "dialProxy",
			Handler:    _Gateway_DialProxy_Handler,
		},
		{
			MethodName: "dialsProxy",
			Handler:    _Gateway_DialsProxy_Handler,
		},
		{
			MethodName: "unreadTids",
			Handler:    _Gateway_UnreadTids_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dsl/gw.proto",
}
